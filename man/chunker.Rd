% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/chunker.R
\name{chunker}
\alias{chunker}
\title{Break Text Into Ordered Word Chunks}
\usage{
chunker(text.var, grouping.var = NULL, n.words, n.chunks, as.string = TRUE,
  rm.unequal = FALSE)
}
\arguments{
\item{text.var}{The text variable}

\item{grouping.var}{The grouping variables.  Default \code{NULL} generates
one word list for all text.  Also takes a single grouping variable or a list
of 1 or more grouping variables.}

\item{n.words}{An integer specifying the number of words in each chunk (must
specify n.chunks or n.words).}

\item{n.chunks}{An integer specifying the number of chunks (must specify
n.chunks or n.words).}

\item{as.string}{logical.  If \code{TRUE} the chunks are returned as a single
string.  If \code{FALSE} the chunks are returned as a vector of single words.}

\item{rm.unequal}{logical. If \code{TRUE} final chunks that are unequal in
length to the other chunks are removed.}
}
\value{
Returns a list of text chunks.
}
\description{
Some visualizations and algorithms require text to be broken into chunks of
ordered words.  \code{chunker} breaks text, optionally by grouping
variables, into equal chunks.  The chunk size can be specified by giving
number of words to be in each chunk or the number of chunks.
}
\examples{
with(DATA, chunker(state, n.chunks = 10))
with(DATA, chunker(state, n.words = 10))
with(DATA, chunker(state, n.chunks = 10, as.string=FALSE))
with(DATA, chunker(state, n.chunks = 10, rm.unequal=TRUE))
with(DATA, chunker(state, person, n.chunks = 10))
with(DATA, chunker(state, list(sex, adult), n.words = 10))
with(DATA, chunker(state, person, n.words = 10, rm.unequal=TRUE))

## Bigger data
with(hamlet, chunker(dialogue, person, n.chunks = 10))
with(hamlet, chunker(dialogue, person, n.words = 300))

\dontrun{
## with polarity hedonmetrics
dat <- with(pres_debates2012[pres_debates2012$person \%in\% qcv(OBAMA, ROMNEY), ],
    chunker(dialogue, list(person, time), n.words = 300))

dat2 <- colsplit2df(list2df(dat, "dialogue", "person&time")[, 2:1])

dat3 <- split(dat2[, -2], dat2$time)
ltruncdf(dat3, 10, 50)

poldat <- lapply(dat3, function(x) with(x, polarity(dialogue, person, constrain = TRUE)))


m <- lapply(poldat, function(x) plot(cumulative(x)))
m <- Map(function(w, x, y, z) {
        w + ggtitle(x) + xlab(y) + ylab(z)
    },
        m,
        paste("Debate", 1:3),
        list(NULL, NULL, "Duration (300 Word Segment)"),
        list(NULL, "Cumulative Average Polarity", NULL)
)

library(gridExtra)
do.call(grid.arrange, m)

## By person
## By person
poldat2 <- Map(function(x, x2){

    scores <- with(counts(x), split(polarity, person))
    setNames(lapply(scores, function(y) {
        y <- list(cumulative_average_polarity = y)
        attributes(y)[["constrained"]] <- TRUE
        qdap:::plot.cumulative_polarity(y) + xlab(NULL) + ylab(x2)
    }), names(scores))

}, poldat, paste("Debate", 1:3))

poldat2 <- lapply(poldat2, function(x) {
    x[[2]] <- x[[2]] + ylab(NULL)
    x
})

poldat2[[1]] <- Map(function(x, y) {
        x + ggtitle(y)
    },
        poldat2[[1]], qcv(Obama, Romney)
)

library(gridExtra)
do.call(grid.arrange, unlist(poldat2, recursive=FALSE))
}
}
\keyword{chunks}
\keyword{group}
\keyword{text}

